\import Utils
\open Nat(+)

-- 1. Определение =.

-- В прелюдии определен тип I с двумя конструкторами left и right, но в отличии от обычных \data эти два конструктора равны.
-- Это означает, что для I нельзя использовать паттерн матчинг, так как иначе было бы легко вывести противоречие.
-- Так как left и right равны, то некоторые a : A и a' : A равны тогда и только тогда, когда существует функция f : I -> A, такая что f left == a и f right == a', где == -- это вычислительное равенство.
-- Тип a = {A} a' определен как тип функций I -> A, удовлетворяющих этому свойству.

\func test {A : \Type} (f : I -> A) : f left = f right
  => path f

-- Чтобы доказать, что a = a, можно взять константную функцию \lam _ => a : I -> A.
\func idp' {A : \Type} {a : A} : a = a => path (\lam _ => a)

-- Если f : A -> B и g : I -> A, то их композиция дает нам pmap.
-- Действительно g доказывает, что g left = g right, а композиция f и g доказывает, что f (g left) = f (g right).
\func pmap'' {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a'
  => path (\lam i => f (p @ i))

-- Функция @, определенная в прелюдии, -- это просто обратная функция к конструктору path.
-- path (f : I -> A) : f left = f right
-- @ (p : a = a') (i : I) : A
-- path f @ i == f i -- бета-эквивалентность
-- path (\lam i => p @ i) == p -- эта-эквивалентность.

-- pmap можно определять по разному, но если использовать определение, данное выше, то он будет обладать хорошими вычислительными свойствами.
-- Например, pmap id = id и pmap (f . g) = pmap f . pmap g, где (.) -- это композиция.
-- Если определить pmap по другому, то эти равенства тоже будут верны, но не вычислительно, то есть их нельзя будет доказать просто по рефлексивности.
\func pmap-idp {A : \Type} {a a' : A} (p : a = a') : pmap (\lam x => x) p = p
  => idp

-- 2. Функциональная экстенсиональность.

-- Функциональная экстенсиональность говорит, что если две функции f и g равны на всех аргументах, то они равны.
-- Ее легко доказать, используя наше определение равенства.
\func funExt {A : \Type} (B : A -> \Type) {f g : \Pi (a : A) -> B a}
             (p : \Pi (a : A) -> f a = g a) : f = g
  => path (\lam i => \lam a => p a @ i)

-- В большинстве других языков с зависимыми типами ее доказать нельзя.
-- Ее можно добавить просто как аксиому, то есть функцию без реализации, но аксиомы обычно не любят добавлять, так как это портит вычислительные свойства языка.

-- Например, если мы добавим аксиому исключенного третьего lem, то легко написать константу foo : Nat, которая не будет вычисляться ни в какое конкретное число.
-- \func lem : \Pi (X : \Type) -> Either X (X -> Empty)
-- \func foo : Nat => \case lem Nat \with { | Left => 0 | Right => 1 }

-- 3. Элиминатор для I.

-- О функции coe, определенной в прелюдии, можно думать как об элиминаторе для I.
-- Она говорит, что для определения функции над I достаточно определить ее для left.
-- Для сравнения элиминатор для Bool говорит, что для определения функции над Bool достаточно определить ее для true и false.

{-
\func coe (P : I -> \Type)
          (a : P left)
          (i : I) : P i \elim i
  | left => a
-}

-- Используя coe, легко доказать, что любой i : I равен left.
\func left=i (i : I) : left = i
  --  | left => idp
  => coe (\lam i => left = i) idp i

-- Мы не можем доказать, что left не равно right, так как мы не можем определить такую функцию для I ни рекурсивно, ни через \data.
{-
\func TI (b : I)
  | left => Unit
  | right => Empty
-}

-- 4. coe и transport.

-- Функция coe тесно связана с transport.
-- Мы можем определить transport через coe.

\func transport'' {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
  => coe (\lam i => B (p @ i)) b right
-- Пусть B' == \lam i => B (p @ i).
-- Тогда
-- B' : I -> \Type
-- B' left == B a
-- B' right == B a'
--
-- \lam x => coe B' x right : B' left -> B' right

-- В ДЗ нужно будет показать, что через transport определеяется частный случай coe.

\func J {A : \Type} {a : A} (B : \Pi (a' : A) -> a = a' -> \Type) (b : B a idp)
  {a' : A} (p : a = a') : B a' p
  => coe (\lam i => B (p @ i) (path (\lam j => p @ I.squeeze i j))) b right

-- 5. Предикаты.

-- Есть несколько способов определять предикаты над некоторым типом A:
-- * Выразить из через уже существующие (например равенство) и различные логические связки. Например, предикат isEven можно выразить как \lam n => \Sigma (k : Nat) (n = 2 * k).
-- * Рекурсивно. Этот способ работает только если A -- тип данных.
-- * Индуктивно.

-- Определение <= через равенство.
\func lessOrEq (n m : Nat) => \Sigma (k : Nat) (n + k = m)

-- Рекурсивное определение предиката <=
\func lessOrEq' (n m : Nat) : \Type
  | 0, _ => \Sigma
  | suc n, 0 => Empty
  | suc n, suc m => lessOrEq' n m

{-

----------
  0 <= m


    n <= m
--------------
suc n <= suc m

 -}

-- Первое индуктивное определение <=
\data LessOrEq (n m : Nat) \with
  | 0, m => zero<=_
  | suc n, suc m => suc<=suc (LessOrEq n m)

\func test11 : LessOrEq 0 100 => zero<=_
\func test12 : LessOrEq 3 67 => suc<=suc (suc<=suc (suc<=suc zero<=_))
-- \func test10 : LessOrEq 1 0 => ....

-- Один и тот же предикат можно определить индуктивно различными способами.
-- Когда мы хотим задать предикат индуктивно, нам нужно просто написать набор правил, которые верны для данного предиката и при этом пораждают его.
-- Например, в LessOrEq у нас два правила: 0 <= m для любого m и, если n <= m, то suc n <= suc m. Любое неравенство можно получить из этих двух правил.

-- Но это не единственный набор правил, который пораждает <=.
-- Например, мы можем взять следующий набор: n <= n для всех n и, если n <= m, то n <= suc m.
-- Этот набор реализован в LessOrEq''.

{-

   n = m
----------
  n <= m

 n <= m
----------
n <= suc m

 -}

-- Второе индуктивное определение <=
\data LessOrEq' (n m : Nat) \with
  | n, m => <=-refl (n = m)
  | n, suc m => <=-step (LessOrEq' n m)

-- 6. \case в языках с зависимыми типами является более сложной конструкцией в общем случаее, чем в языках без них.

\func example (n : Nat) =>
  \case n \return Nat \with { | 0 => 0 | suc n => n }

-- foo лучше доказать, просто обобщив утверждение, но мы докажем ее через \case, чтобы продемонстировать возможности этой конструкции.
\func foo {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
  -- Перед \with мы можем написать \return <expr>, где <expr> -- это тип, который возвращается из \case.
  -- После выражения, на котором мы паттерн матчимся, можно написать \as b, где b -- это переменная, которая будет связана в этой конструкции.
  -- Эту переменную можно использовать в выражении, которое идет после \return.
  -- Идея в том, что возвращаемый тип может зависеть от выражения, на котором мы паттерн матчимся.
  -- Эту конструкцию можно использовать, чтобы эту зависимость явно указать.
  \case p a \as b \return b = not (not b) \with {
    | true => idp -- В каждом отдельном случае нам нужно будет вернуть указанный после \return тип, в котором b заменено на соответствующий паттерн. Например, здесь нужно вернуть значение типа true = not (not true).
    | false => idp -- А здесь мы возвращаем значение типа false = not (not false).
  }

-- foo можно переписать через helper.
\func foo' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) => aux (p a)
  \where {
    \func aux (b : Bool) : b = not (not b)
      | true => idp
      | false => idp
  }

-- 7. Пример доказательств через \case.

\func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | cons x xs => \case p x \with {
    | true => cons x (filter p xs)
    | false => filter p xs
  }

\func <=-step-lem {n m : Nat} (n<=m : LessOrEq n m) : n `LessOrEq` suc m \elim n, m, n<=m
  | 0, m, zero<=_ => zero<=_
  | suc n, suc m, suc<=suc n<=m => suc<=suc (<=-step-lem n<=m)

-- Докажем, что длина отфильтрованного списка не превышает длины исходного.
\func filter-lem {A : \Type} (p : A -> Bool) (xs : List A)
  : length (filter p xs) `LessOrEq` length xs \elim xs
  | nil => zero<=_
  | cons a xs => \case p a \as b \return
                                    LessOrEq (length (\case b \with {
                                      | true => cons a (filter p xs)
                                      | false => filter p xs
                                    })) (suc (length xs))
  \with {
    | true => suc<=suc (filter-lem p xs)
    | false => <=-step-lem (filter-lem p xs)
  }

-- 8. \case на idp.

-- Когда мы паттерн матчимся на некотором значении e, связь этого выражения с резльтатом паттерн матчинга теряется.
-- Например, в выражении \case e \with { | pat => expr } в expr мы даже не сможем доказать, что e равно pat.
-- Иногда бывает необходимо запоминать эту связь.
-- Для этого можно использовать следующий трюк.
-- Мы в \case кроме самого выражения еще паттерн матчимся на idp, но указываем ему тип, который зависит от первого значения.
-- Тогда в каждом случае q будем доказательством равенства между исходным значением и паттерном.
\func baz {A : \Type}
          (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
  -- Мы можем явно указывать не только тип возвращаемого значения, но и типы выражений, на которых мы паттерн матчимся.
  -- И в них также можно использовать переменные, связанные в \as.
  \case p a \as b, idp : b = p a \with {
    | true, q => transport (\lam b => b = not (not b)) q idp -- Здесь q : true = p a
    | false, q => transport (\lam b => b = not (not b)) q idp -- Здесь q : false = p a
  }

-- 9. Еще один пример.

\func BoolFuncLem (f : Bool -> Bool) (x : Bool) : f (f (f x)) = f x
  => \case \elim x, f true \as b, idp : f true = b, f false \with {
    | true, true, p, _ => pmap f (pmap f p *> p)
    | true, false, p, true => {?}
    | true, false, p, false => {?}
    | false, true, p, true => {?}
    | false, true, p, false => {?}
    | false, false, p, true => {?}
    | false, false, p, false => {?}
  }
